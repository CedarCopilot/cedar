---
title: 'Custom Message Rendering'
description: 'Create custom message handlers and renderers for structured data'
---

Cedar's unified message processor system enables all UI interfaces that come from streamed or sent events from the backend. This system processes structured objects with a `type` field, enabling Generative UI, state mutations, diff applying, and all frontend interactions with structured data from your agents.

### Structured Object Shape

Any object that this system processes must have a `type` field:

```typescript
interface StructuredObject {
	type: string;
	[key: string]: unknown;
}
```

When the backend sends structured data, Cedar's `processStructuredMessage()` function:

1. Checks for a `type` field
2. Finds all registered **processors** for that type
3. Sorts by priority (highest first) and runs validation
4. Executes the first valid processor's business logic and/or rendering
5. Falls back to JSON display if no processors match

## Levels of Control

The following examples demonstrate Cedar's Generative UI capabilities - where your agent can send structured data that updates your UI and executes actions in real-time.

Let's use an action example to show the three different levels of control. When your backend sends this structured object:

```typescript
{
  type: 'action',
  stateKey: 'todos',
  setterKey: 'addTodo',
  args: ['Review pull request #123', 'high'],
  description: 'Add high priority todo item'
}
```

### Full Control: Execute + Custom Chat Display

Register a processor that handles business logic and controls what appears in chat.

<Info>
	Processors never automatically add messages to chat. You must explicitly call
	`store.addMessage()` if you want something to appear.
</Info>

```typescript
import { useMessageProcessor } from 'cedar-os';

// Complete control - execute logic AND control chat display
useMessageProcessor({
	type: 'action',
	namespace: 'todos', // Handle only todo actions
	priority: 10, // Higher priority than defaults

	// Execute business logic
	execute: (obj, store) => {
		console.log(
			'Processing todo action:',
			obj.stateKey,
			obj.setterKey,
			obj.args
		);

		// Execute the state setter
		if (obj.stateKey && obj.setterKey) {
			const args = Array.isArray(obj.args) ? obj.args : [];
			store.executeCustomSetter(obj.stateKey, obj.setterKey, ...args);
		}

		// Update UI components outside of chat
		if (obj.args?.[1] === 'high') {
			// Show notification in notification panel
			store.executeCustomSetter(
				'notifications',
				'show',
				'High priority todo added!'
			);
			// Update dashboard badge count
			store.executeCustomSetter('dashboard', 'incrementUrgentTasks');
			// Highlight todo section in sidebar
			store.executeCustomSetter('sidebar', 'highlightSection', 'todos');
		}

		// Explicitly add to chat with custom message
		store.addMessage({
			role: 'assistant',
			type: 'custom_todo',
			content: `Added todo: ${obj.args?.[0]}`,
			priority: obj.args?.[1],
			originalAction: obj,
		});
	},

	// Only handle todo actions
	validate: (obj) => obj.type === 'action' && obj.stateKey === 'todos',
});

// Register a renderer for the custom message type
useMessageProcessor({
	type: 'custom_todo',
	render: ({ message }) => {
		const priority = message.priority;

		return (
			<div
				className={`border-l-4 p-4 ${
					priority === 'high'
						? 'border-red-500 bg-red-50'
						: 'border-blue-500 bg-blue-50'
				}`}>
				<div className='flex items-center gap-2'>
					<span className='font-semibold'>ðŸš€ Todo Added</span>
					{priority === 'high' && (
						<span className='text-xs px-2 py-1 rounded bg-red-200 text-red-800'>
							HIGH PRIORITY
						</span>
					)}
				</div>
				<p className='mt-2'>{message.content}</p>
			</div>
		);
	},
});
```

### Execute Only: No Chat Display

Register a processor that only executes business logic without adding anything to chat.

```tsx
import { useMessageProcessor } from 'cedar-os';

// Execute only - no chat display
useMessageProcessor({
	type: 'action',
	namespace: 'silent',
	priority: 10, // Higher priority than defaults

	// Execute business logic only
	execute: (obj, store) => {
		console.log('Silent action execution:', obj.stateKey, obj.setterKey);

		// Execute the state setter
		if (obj.stateKey && obj.setterKey) {
			const args = Array.isArray(obj.args) ? obj.args : [];
			store.executeCustomSetter(obj.stateKey, obj.setterKey, ...args);
		}

		// Update other UI components
		store.executeCustomSetter(
			'notifications',
			'show',
			'Action completed silently'
		);

		// NO addMessage call = nothing appears in chat
	},

	validate: (obj) => obj.type === 'action' && obj.silent === true,
});
```

### No Control: Cedar Defaults

Don't register any custom processors - Cedar's built-in default processors will handle everything automatically:

```tsx
// No registration needed - Cedar's default action processor:
// 1. Executes: store.executeCustomSetter('todos', 'addTodo', 'Review pull request #123', 'high')
// 2. Adds action message to chat with default rendering:

{
  "type": "action",
  "stateKey": "todos",
  "setterKey": "addTodo",
  "args": ["Review pull request #123", "high"],
  "description": "Add high priority todo item"
}
```

This approach requires no code - the action gets executed and displayed automatically using Cedar's default processors (located in `packages/cedar-os/src/store/messages/defaultHandlers.ts`).

## Default Registered Object Types

Cedar includes three built-in processors that are automatically registered with `namespace: 'default'` and `priority: 0`:

### `message`

Handles basic text messages with optional role specification.

```typescript
// Handled automatically when backend sends:
{
  type: 'message',
  content: 'Hello from the agent!',
  role: 'assistant' // optional, defaults to 'assistant'
}
```

### `action`

Executes state setters and renders action data.

```typescript
// Handled automatically when backend sends:
{
  type: 'action',
  stateKey: 'myState',
  setterKey: 'updateValue',
  args: ['newValue'],
  description: 'Updated user preference'
}
```

### `stage_update`

Shows agent progress with status indicators.

```typescript
// Handled automatically when backend sends:
{
  type: 'stage_update',
  status: 'in_progress', // 'in_progress' | 'complete' | 'error' | 'thinking'
  message: 'Analyzing document...'
}
```

## Mastra Renderers

Mastra agents stream real-time events during execution. Cedar provides automatic renderers for all Mastra event types to visualize agent workflows as they happen.

#### Mastra Event Types

When a Mastra agent runs, it streams these structured events:

- `start` - Agent execution begins
- `step-start` - Individual step starts
- `tool-call` - Agent calls a tool
- `tool-result` - Tool returns result
- `step-finish` - Individual step completes
- `tool-output` - Tool produces output
- `step-result` - Step produces result
- `step-output` - Step produces output
- `finish` - Agent execution completes

#### Automatic Usage

Cedar provides pre-built processors for all Mastra events (downloaded with Cedar components). Simply register them to automatically visualize agent workflows:

```tsx
import { mastraProcessors } from 'cedar-os-components/chatMessages/MastraProcessors';
import { useMessageProcessors } from 'cedar-os';

function MyComponent() {
	useMessageProcessors(mastraProcessors);
	return <div>My component</div>;
}
```

#### Overriding Specific Processors

You can override any Mastra processor while keeping the rest. Here's how to customize the `tool-call` processor:

```tsx
import { useMessageProcessor, useMessageProcessors } from 'cedar-os';
import { mastraProcessors } from 'cedar-os-components/chatMessages/MastraProcessors';
import type { MastraMessage } from 'cedar-os';

function CustomMastraProcessors() {
	// Register all default Mastra processors
	useMessageProcessors(mastraProcessors);

	// Override the tool-call processor with higher priority
	useMessageProcessor({
		type: 'tool-call',
		namespace: 'custom',
		priority: 10, // Higher than default (0)

		// Custom rendering for tool calls
		render: ({ message }) => {
			const toolMsg = message as MastraMessage<'tool-call'>;
			const { toolName, args } = toolMsg.payload as {
				toolName?: string;
				args?: unknown;
			};

			return (
				<div className='border-l-4 border-blue-500 pl-3 py-2 my-2 bg-blue-50'>
					<div className='flex items-center gap-2'>
						<span className='text-blue-700 font-semibold'>
							ðŸ”§ {toolName ?? 'tool'}
						</span>
						<span className='text-xs text-blue-600 bg-blue-200 px-2 py-1 rounded'>
							Tool Call
						</span>
					</div>
					{args && (
						<pre className='mt-2 text-xs text-blue-800 bg-white p-2 rounded'>
							{JSON.stringify(args, null, 2)}
						</pre>
					)}
				</div>
			);
		},

		validate: (msg) => msg.type === 'tool-call',
	});

	return null;
}
```

This pattern allows you to selectively enhance specific Mastra events while maintaining the default behavior for others. The higher priority ensures your custom processor takes precedence.

## Advanced Usage Examples

### Conditional Rendering

Create processors that render different components based on message fields:

```tsx
import { useMessageProcessor } from 'cedar-os';

// Processor for conditional message rendering
useMessageProcessor({
	type: 'conditional_message',
	priority: 0,

	render: ({ message }) => {
		// Different rendering based on message properties
		if (message.priority === 'urgent') {
			return (
				<div className='bg-red-100 border-red-500 border-l-4 p-4'>
					<div className='flex items-center'>
						<span className='text-red-600 font-bold'>ðŸš¨ URGENT</span>
						<span className='ml-2'>{message.content}</span>
					</div>
				</div>
			);
		}

		if (message.category === 'code') {
			return (
				<div className='bg-gray-900 text-green-400 p-4 rounded font-mono'>
					<pre>{message.content}</pre>
					<button
						onClick={() => navigator.clipboard.writeText(message.content)}
						className='mt-2 text-blue-400 hover:text-blue-300'>
						Copy Code
					</button>
				</div>
			);
		}

		// Default rendering
		return <div className='p-2'>{message.content}</div>;
	},

	validate: (msg) => msg.type === 'conditional_message',
});
```

### Rendering events beyond the chat

Cedar is built on the principle that **chat is not the only place your agent should live**. The message system is designed to work across different UI contexts.

```tsx
import { useMessageProcessor } from 'cedar-os';

// Register processor for agent prompts in any UI context
useMessageProcessor({
	type: 'prompt_called',
	namespace: 'analytics',
	priority: 5,

	// Execute business logic - no chat rendering
	execute: (obj, store) => {
		// Could trigger UI updates, logs, analytics, etc.
		console.log('Agent called prompt:', obj.promptName);

		// Update some UI state
		store.executeCustomSetter(
			'agentStatus',
			'setCurrentPrompt',
			obj.promptName
		);

		// Optionally add to chat if in chat context
		if (store.showChat) {
			store.addMessage({
				role: 'assistant',
				type: 'stage_update',
				content: '',
				status: 'in_progress',
				message: `Executing ${obj.promptName}...`,
			});
		}
	},

	// No render function = doesn't add to chat by default

	validate: (obj) =>
		obj.type === 'prompt_called' && typeof obj.promptName === 'string',
});
```

This system enables agents to communicate with your application through structured data, whether in chat interfaces, dashboards, or any other UI component that needs to respond to agent events.

## Next Steps

- Learn about [agent input context](/getting-started/chat/agent-input-context)
- Explore [subscribing to state](/getting-started/chat/subscribing-state)

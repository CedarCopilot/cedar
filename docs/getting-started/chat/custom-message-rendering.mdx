---
title: Custom Message Rendering
description: Create custom message handlers and renderers for structured data
---

Cedar handles all messages of type object in a unified way through its message processor system. This system processes any structured object containing a `type` field, enabling Generative UI, state mutations, and all frontend interactions with structured data from your agents.

### Structured Object Interface

All structured objects processed by Cedar must conform to this interface:

```typescript
interface StructuredObject {
	type: string;
	[key: string]: unknown;
}
```

This simple interface requirement allows Cedar to handle any custom message type while maintaining type safety and predictable behavior.

## How Cedar Processes Messages Under the Hood

When the backend sends structured data, Cedar processes it through two sequential phases:

### Phase 1: Message Processing and Validation

Cedar's `processStructuredMessage()` function handles incoming structured objects:

1. **Type Validation**: Checks for a required `type` field
2. **Processor Lookup**: Finds all registered **processors** for that type
3. **Priority Selection**: Selects the highest `priority` processor that passes validation
4. **Execution**: Executes the processor's `execute` function for business logic
5. **Fallback**: If no processor matches, adds the raw object to chat

### Phase 2: Chat Rendering

When a message is added to the chat (either by a processor or the fallback):

1. **Renderer Lookup**: Cedar checks if there's a registered `render` function for the message type
2. **Custom Rendering**: If found, uses the custom renderer to display the message
3. **Default Rendering**: If no custom renderer exists, falls back to JSON stringification

This two-phase approach separates business logic from presentation, giving you complete control over both aspects.

## What this enables

This architecture gives Cedar flexibility in handling structured data:

**Complete Control**: You can register any message type and specify both processing and rendering behaviors manually, or let the defaults handle everything automatically.

**Granular Customization**: Mix and match custom processors with default rendering, or use default processing with custom rendering - or override everything with your own implementation.

**Graceful Fallbacks**: If no custom processor is registered, Cedar automatically adds the message to chat and renders it as JSON, ensuring nothing is ever lost.

**Type Safety**: The entire system maintains full TypeScript type safety from your backend message definitions through to your frontend renderers.

## CustomMessage Type Helper

The `CustomMessage` helper provides type safety to custom message types:

### Interface Definition

```typescript
// Base properties that all messages share
interface BaseMessage {
	id: string;
	role: 'bot' | 'user' | 'assistant';
	content: string;
	createdAt?: string;
	metadata?: Record<string, unknown>;
	type: string;
}

// Helper for creating typed custom messages
type CustomMessage<
	T extends string,
	P extends Record<string, unknown> = Record<string, never>
> = BaseMessage & { type: T } & P & Record<string, unknown>;
```

### Usage

The `CustomMessage` type helper takes two generic parameters:

- `T` - The exact string literal for your message type (e.g., `'progress_update'`)
- `P` - An object defining your custom fields (optional, defaults to no additional fields)

## Complete Example: Building a Custom Message Type

Let's walk through creating a custom message type step by step. We'll build a `progress_update` message type that shows task progress with custom rendering.

<Steps>
  <Step title="Understanding the MessageProcessor Interface">
    The `MessageProcessor` interface controls both business logic and rendering:

    ```typescript
    interface MessageProcessor<T extends Message = Message> {
    	type: string; // Message type to handle (e.g., 'progress_update')
    	namespace?: string; // Optional namespace for organization
    	priority?: number; // Higher numbers = higher priority (default: 0)

    	// Optional: Execute business logic when structured data arrives
    	execute?: (obj: T, store: CedarStore) => void | Promise<void>;

    	// Optional: Provide custom rendering for messages in chat
    	render?: React.ComponentType<{ message: T }>;

    	// Optional: Validate that incoming data belongs to this processor
    	validate?: (obj: Message) => obj is T;
    }
    ```

    <Info>
    	**Important**: If you provide an `execute` function, you must manually call
    	`store.addMessage()` if you want the message to appear in chat. The `execute`
    	function completely overrides Cedar's default behavior.
    </Info>
  </Step>

  <Step title="Complete Implementation">
    Here's a full implementation showing both custom processing and rendering:

```typescript
// Create the render component
const ProgressRenderer: MessageRender<ProgressMessage> = ({ message }) => {
	const getStatusColor = (level: ProgressLevel) => {
		switch (level) {
			case 'error':
				return 'bg-red-200 text-red-600 border-red-500';
			case 'warning':
				return 'bg-yellow-200 text-yellow-600 border-yellow-500';
			default:
				return 'bg-blue-200 text-blue-600 border-blue-500';
		}
	};

	const getStatusIcon = (status: string) => {
		switch (status) {
			case 'completed':
				return '‚úÖ';
			case 'failed':
				return '‚ùå';
			case 'running':
				return 'üîÑ';
			default:
				return '‚è≥';
		}
	};

	return (
		<div
			className={`border-l-4 p-4 my-2 rounded-r ${getStatusColor(
				message.level
			)}`}>
			<div className='flex items-center justify-between mb-2'>
				<h4 className='font-semibold flex items-center gap-2'>
					<span>{getStatusIcon(message.status)}</span>
					{message.title}
				</h4>
				<span className='text-xs px-2 py-1 rounded-full bg-white bg-opacity-50'>
					{message.status.toUpperCase()}
				</span>
			</div>

			<div className='w-full bg-gray-200 rounded-full h-2 mb-2'>
				<div
					className='bg-blue-500 h-2 rounded-full transition-all duration-300'
					style={{ width: `${message.progress}%` }}
				/>
			</div>

			<div className='flex justify-between items-center text-sm'>
				<span>{message.progress}% complete</span>
				<span>Task: {message.taskId}</span>
			</div>
		</div>
	);
};

// Define the custom message type with precise field specifications
type ProgressLevel = 'info' | 'warning' | 'error';
export type ProgressMessage = CustomMessage<
	'progress_update',
	{
		taskId: string;
		progress: number; // 0-100
		status: 'pending' | 'running' | 'completed' | 'failed';
		title: string;
		level: ProgressLevel;
	}
>;

// Register the processor with the useMessageProcessor hook
useMessageProcessor<ProgressMessage>({
	type: 'progress_update',
	namespace: 'custom',
	priority: 5,

	execute: (obj, store) => {
		// Custom business logic - update app state
		store.executeCustomSetter('tasks', 'updateProgress', {
			taskId: obj.taskId,
			progress: obj.progress,
			status: obj.status,
		});

		// Show notifications for completed/failed tasks
		if (obj.status === 'completed' || obj.status === 'failed') {
			store.executeCustomSetter('notifications', 'show', {
				title: obj.status === 'completed' ? 'Task Completed!' : 'Task Failed',
				message: obj.title,
				type: obj.status === 'completed' ? 'success' : 'error',
			});
		}

		// IMPORTANT: Manually add message to chat since we have an execute function
		store.addMessage(obj);
	},

	render: ProgressRenderer,

	validate: (msg): msg is ProgressMessage =>
		msg.type === 'progress_update' &&
		typeof (msg as any).taskId === 'string' &&
		typeof (msg as any).progress === 'number' &&
		typeof (msg as any).status === 'string' &&
		typeof (msg as any).title === 'string' &&
		typeof (msg as any).level === 'string',
});
```
  </Step>

  <Step title="Typing Benefits of useMessageProcessor<T>">
    When you use `useMessageProcessor<ProgressMessage>()`, all processor methods are fully typed:

    - `execute` receives `obj: ProgressMessage` (not generic `Message`)
    - `render` receives `message: ProgressMessage` with all your custom fields
    - `validate` must return `msg is ProgressMessage` for proper type narrowing
    - Full IntelliSense and type checking for all your custom fields
  </Step>
</Steps>

## Built-in Message Types

Cedar includes three built-in processors that are automatically registered with `namespace: 'default'` and `priority: 0`. These handle the most common message types you'll encounter:

<AccordionGroup>

<Accordion title="message - Basic Text Messages">

Handles basic text messages with optional role specification. This is the most common message type for simple text communication.

```typescript
// Handled automatically when backend sends:
{
  type: 'message',
  content: 'Hello from the agent!',
  role: 'assistant' // optional, defaults to 'assistant'
}
```

**Behavior:**

- Converts structured message to a text message
- Adds to chat with the specified role (defaults to 'assistant')
- Uses default text rendering (markdown support)

</Accordion>

<Accordion title="action - State Management & Execution (Generative UI)">

The `action` type is Cedar's primary mechanism for implementing Generative UI. It allows your agents to execute frontend state changes.

```typescript
// Handled automatically when backend sends:
{
  type: 'action',
  stateKey: 'todos',
  setterKey: 'addTodo',
  args: ['Review pull request #123', 'high'],
  description: 'Add high priority todo item'
}
```

**Default Behavior:**

- Executes `store.executeCustomSetter(stateKey, setterKey, ...args)`
- Adds the action message to chat for visibility
- Renders with action-specific styling showing completion status

### ActionMessageFor Type Helper

For type-safe action messages, use the `ActionMessageFor` helper:

```typescript
import { ActionMessageFor } from 'cedar-os';

// Define a strongly-typed action message
type AddTodoMessage = ActionMessageFor<
	'todos', // stateKey
	'addTodo', // setterKey
	[string, 'high' | 'medium' | 'low'] // args tuple
>;
```

### useActionMessageProcessor Hook

Cedar provides a specialized hook for registering action message processors with enhanced type safety:

```typescript
import { useActionMessageProcessor } from 'cedar-os';

useActionMessageProcessor<AddTodoMessage>({
	namespace: 'todos',
	priority: 10,
	setterKey: 'addTodo', // Automatically filters to this setter

	execute: (obj, store) => {
		// obj is fully typed as AddTodoMessage
		const todoText = obj.args[0]; // string
		const priority = obj.args[1]; // 'high' | 'medium' | 'low'

		store.executeCustomSetter(obj.stateKey, obj.setterKey, ...obj.args);
		store.addMessage(obj);
	},

	render: ({ message }) => {
		// message is fully typed as AddTodoMessage
		return <CustomTodoRenderer message={message} />;
	},
});
```

**Benefits:**

- **Type Safety**: All methods receive the exact action message type
- **Automatic Filtering**: Only handles actions with the specified `setterKey`
- **Default Validation**: Includes built-in validation for action message structure

</Accordion>

<Accordion title="stage_update - Progress Indicators">

Shows agent progress with status indicators. Perfect for keeping users informed about long-running operations or multi-step processes.

```typescript
// Handled automatically when backend sends:
{
  type: 'stage_update',
  status: 'in_progress', // 'in_progress' | 'complete' | 'error' | 'thinking'
  message: 'Analyzing document...'
}
```

**Behavior:**

- Adds stage update message to chat
- Renders with animated status indicators based on the status
- Provides visual feedback for agent workflow progress

**Available Status Types:**

- `in_progress` - Shows loading animation
- `complete` - Shows checkmark with completion styling
- `error` - Shows error indicator with error styling
- `thinking` - Shows thinking animation

</Accordion>

</AccordionGroup>

## Mastra Message Types and Default Processors

Mastra agents stream real-time events during execution. Cedar provides automatic processors for all Mastra event types to handle both execution logic and rendering.

### Mastra Event Types

When a Mastra agent runs, it automatically streams these structured message types:

- `start` - Agent workflow begins
- `step-start` - Individual step begins
- `tool-call` - Tool is being called
- `tool-result` - Tool call returns result
- `step-finish` - Individual step completes
- `tool-output` - Tool produces output
- `step-result` - Step produces result
- `step-output` - Step produces final output
- `finish` - Agent workflow completes

### Using Mastra Processors

Cedar provides pre-built processors for all Mastra events with default rendering. These processors are included in `cedar-os-components/chatMessages/MastraProcessors.tsx` and can be registered using the `useMessageProcessors` hook:

```tsx
import { mastraProcessors } from 'cedar-os-components/chatMessages/MastraProcessors';
import { useMessageProcessors } from 'cedar-os';

useMessageProcessors<MastraMessage<MastraEventType>>(mastraProcessors);
```

All Mastra processors use `namespace: 'mastra'` and `priority: 0` by default. You can override individual Mastra processors by registering custom ones with higher priority for specific event types.

## Advanced Usage Examples

<AccordionGroup>

<Accordion title="Conditional Rendering">

Create processors that render different components based on message fields:

```tsx
import { useMessageProcessor, CustomMessage } from 'cedar-os';

// Define the conditional message type
type ConditionalMessage = CustomMessage<
	'conditional_message',
	{
		priority?: 'urgent' | 'normal';
		category?: 'code' | 'text';
	}
>;

useMessageProcessor<ConditionalMessage>({
	type: 'conditional_message',
	priority: 0,

	render: ({ message }) => {
		if (message.priority === 'urgent') {
			return (
				<div className='bg-red-100 border-red-500 border-l-4 p-4'>
					<div className='flex items-center'>
						<span className='text-red-600 font-bold'>üö® URGENT</span>
						<span className='ml-2'>{message.content}</span>
					</div>
				</div>
			);
		}

		if (message.category === 'code') {
			return (
				<div className='bg-gray-900 text-green-400 p-4 rounded font-mono'>
					<pre>{message.content}</pre>
					<button
						onClick={() => navigator.clipboard.writeText(message.content)}
						className='mt-2 text-blue-400 hover:text-blue-300'>
						Copy Code
					</button>
				</div>
			);
		}

		return <div className='p-2'>{message.content}</div>;
	},

	validate: (msg): msg is ConditionalMessage => msg.type === 'conditional_message',
});
```

</Accordion>

<Accordion title="Rendering events beyond the chat">

Cedar is built on the principle that **chat is not the only place your agent should live**. The message system is designed to work across different UI contexts.

```tsx
import { useMessageProcessor, CustomMessage } from 'cedar-os';

// Define the prompt called message type
type PromptCalledMessage = CustomMessage<
	'prompt_called',
	{
		promptName: string;
	}
>;

// Register processor for agent prompts in any UI context
useMessageProcessor<PromptCalledMessage>({
	type: 'prompt_called',
	namespace: 'analytics',
	priority: 5,

	execute: (obj, store) => {
		console.log('Agent called prompt:', obj.promptName);

		store.executeCustomSetter(
			'agentStatus',
			'setCurrentPrompt',
			obj.promptName
		);

		if (store.showChat) {
			store.addMessage({
				role: 'assistant',
				type: 'stage_update',
				content: '',
				status: 'in_progress',
				message: `Executing ${obj.promptName}...`,
			});
		}
	},

	validate: (obj): obj is PromptCalledMessage =>
		obj.type === 'prompt_called' && typeof obj.promptName === 'string',
});
```

</Accordion>
</AccordionGroup>

This system enables agents to communicate with your application through structured data, whether in chat interfaces, dashboards, or any other UI component that needs to respond to agent events.

## Best Practices

### Organizing Your Processors

Cedar recommends keeping all your message processors in a single file for better organization and maintainability:

```typescript
// messageProcessors.tsx
import { 
	useMessageProcessor, 
	useMessageProcessors, 
	CustomMessage,
	ActionMessage,
	MastraMessage,
	MastraEventType,
	MessageProcessor
} from 'cedar-os';
import { mastraProcessors } from 'cedar-os-components/chatMessages/MastraProcessors';

// Define custom message types
type AlertMessage = CustomMessage<'alert', { level: string; text: string }>;

const customAlertProcessor: MessageProcessor<AlertMessage> = {
	type: 'alert',
	render: AlertRenderer,
};

const customActionProcessor: MessageProcessor<ActionMessage> = {
	type: 'action',
	execute: customActionLogic,
	render: CustomActionRenderer,
};

export function useAllMessageProcessors() {
	useMessageProcessors<MastraMessage<MastraEventType>>(mastraProcessors);
	useMessageProcessor<AlertMessage>(customAlertProcessor);
	useMessageProcessor<ActionMessage>(customActionProcessor);
}
```

Then import and use in your components:

```typescript
import { useAllMessageProcessors } from './messageProcessors';

function MyComponent() {
	useAllMessageProcessors();
	return <div>My component with all processors registered</div>;
}
```

## Next Steps

- Learn about [agent input context](/getting-started/chat/agent-input-context)
- Explore [subscribing to state](/getting-started/chat/subscribing-state)

---
title: 'Storage Configuration'
description: 'Configure how Cedar persists chat messages and manages threads'
---

Cedar provides a flexible storage system for managing chat messages with automatic persistence and **automatic thread management**. By default, Cedar uses **local storage** - no configuration required.

# Quick Start

Cedar works out of the box with browser localStorage - no setup needed. Optionally, you can configure the storage key.

With no configured storage adapter, Cedar will:

- Use local storage with 'cedar' prefix
- Use 'default' as the user ID (no userId needed)
- Load any existing threads for the default user
- Select the first thread or creates a 'default' thread
- Persist messages as they're added

# Storage Options

Cedar supports four storage adapters:

1. **Local Storage** (default) - Browser localStorage
2. **Remote Storage** - HTTP API endpoints
3. **No Storage** - Disables persistence
4. **Custom Storage** - Your own implementation

Configure storage by passing the `storage` prop to CedarCopilot:

<CodeGroup>

```typescript Local Storage (Default)
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			// No storage prop needed - uses local storage by default.
			// Optionally pass in user ID
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Local Storage (Custom Key)
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'local',
				options: {
					key: 'my-app', // Optional: defaults to 'cedar'
				},
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Remote Storage
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'remote',
				options: {
					baseURL: 'https://api.myapp.com',
					headers: {
						// Optional
						Authorization: 'Bearer your-token',
						'X-Custom-Header': 'value',
					},
				},
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript No Storage
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot storage={{ type: 'none' }} userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Custom Storage
import { CedarCopilot } from 'cedar-os';

const myCustomAdapter = {
	async listThreads(userId) {
		return await myDatabase.getThreads(userId);
	},
	async loadMessages(userId, threadId) {
		return await myDatabase.getMessages(userId, threadId);
	},
	async persistMessage(userId, threadId, message) {
		await myDatabase.appendMessage(userId, threadId, message);
	},
};

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'custom',
				adapter: myCustomAdapter,
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

# Additional Configuration Requirements by Storage Type

### Local Storage & No Storage

**No additional configuration needed** - these options work out of the box.

### Remote Storage

You can implement any or all of the following routes. **If an endpoint is not implemented, Cedar will gracefully skip that functionality.**
For example:

- If you don't implement the save messages endpoints, Cedar assumes you handle persistence elsewhere
- If you don't implement the list threads endpoints, Cedar will work with just one thread

**Single-User or Backend-Handled User Context:**
If your backend handles user context through authentication headers, implement these routes:

| Method | Endpoint                                   | Purpose                       | Request Body         | Response       |
| ------ | ------------------------------------------ | ----------------------------- | -------------------- | -------------- |
| GET    | `/threads`                                 | List threads (optional)       | -                    | `ThreadMeta[]` |
| POST   | `/threads`                                 | Create new thread (optional)  | `{threadId, meta}`   | -              |
| GET    | `/threads/{threadId}`                      | Get thread messages           | -                    | `Message[]`    |
| PUT    | `/threads/{threadId}`                      | Update thread meta (optional) | `{meta: ThreadMeta}` | -              |
| DELETE | `/threads/{threadId}`                      | Delete thread (optional)      | -                    | -              |
| POST   | `/threads/{threadId}/messages`             | Add single message            | `{message: Message}` | -              |
| PUT    | `/threads/{threadId}/messages/{messageId}` | Update message (optional)     | `{message: Message}` | -              |
| DELETE | `/threads/{threadId}/messages/{messageId}` | Delete message (optional)     | -                    | -              |

**Multi-User with URL-Based User Context:**
If your app has multiple users and you want to pass the user ID in the URL, implement these routes:

| Method | Endpoint                                               | Purpose                       | Request Body         | Response       |
| ------ | ------------------------------------------------------ | ----------------------------- | -------------------- | -------------- |
| GET    | `/threads?userId={id}`                                 | List threads (optional)       | -                    | `ThreadMeta[]` |
| POST   | `/threads?userId={id}`                                 | Create new thread (optional)  | `{threadId, meta}`   | -              |
| GET    | `/threads/{threadId}?userId={id}`                      | Get user's thread messages    | -                    | `Message[]`    |
| PUT    | `/threads/{threadId}?userId={id}`                      | Update thread meta (optional) | `{meta: ThreadMeta}` | -              |
| DELETE | `/threads/{threadId}?userId={id}`                      | Delete thread (optional)      | -                    | -              |
| POST   | `/threads/{threadId}/messages?userId={id}`             | Add message to user's thread  | `{message: Message}` | -              |
| PUT    | `/threads/{threadId}/messages/{messageId}?userId={id}` | Update message (optional)     | `{message: Message}` | -              |
| DELETE | `/threads/{threadId}/messages/{messageId}?userId={id}` | Delete message (optional)     | -                    | -              |

### Custom Storage

Implement your own storage solution by providing a custom adapter:

<CodeGroup>

```typescript Interface
interface BaseStorageAdapter {
	// Required methods
	loadMessages(
		userId: string | null | undefined,
		threadId: string
	): Promise<Message[]>;
	persistMessage(
		userId: string | null | undefined,
		threadId: string,
		message: Message
	): Promise<Message>; // returns the saved message

	// Optional thread methods
	listThreads?(userId?: string | null): Promise<ThreadMeta[]>;
	createThread?(
		userId: string | null | undefined,
		threadId: string,
		meta: ThreadMeta
	): Promise<ThreadMeta>; // returns new meta
	updateThread?(
		userId: string | null | undefined,
		threadId: string,
		meta: ThreadMeta
	): Promise<ThreadMeta>; // returns updated meta
	deleteThread?(
		userId: string | null | undefined,
		threadId: string
	): Promise<ThreadMeta | undefined>; // returns deleted meta (optional)

	// Optional message methods
	updateMessage?(
		userId: string | null | undefined,
		threadId: string,
		message: Message
	): Promise<Message>; // returns updated message
	deleteMessage?(
		userId: string | null | undefined,
		threadId: string,
		messageId: string
	): Promise<Message | undefined>; // returns deleted message (optional)
}
```

All mutator/creator functions return the object they operate on, making it easy to work with the freshly-persisted data (IDs, timestamps, etc.).

```typescript Example Implementation
import { CedarCopilot } from 'cedar-os';

// Your custom storage implementation
const myCustomAdapter = {
	async listThreads(userId) {
		return await myDatabase.getThreads(userId);
	},

	async loadMessages(userId, threadId) {
		return await myDatabase.getMessages(userId, threadId);
	},

	async persistMessage(userId, threadId, message) {
		await myDatabase.appendMessage(userId, threadId, message);
	},
};

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'custom',
				adapter: myCustomAdapter,
			}}
			userId='user-123' // User ID passed in initial configuration
		>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

## How Default Message Storage Works

Cedar automatically handles message storage operations in the following way:

**Thread & Message Loading:**

- **When user ID changes**: Automatically loads all threads for that user
- **When storage adapter changes**: Loads threads from the new storage system
- **When the thread ID changes**: Automatically loads in all messages for that thread

**Message Persistence & Thread Updates:**

- **User messages**: Persisted immediately when sent via `sendMessage()` (internally calls `store.persistMessage`).
- **Assistant responses**:
  - **Non-streaming**: Persisted right after the LLM reply finishes.
  - **Streaming**: Buffered during streaming and persisted once when the stream ends.
- **Automatic thread meta update**: Every persisted message refreshes the threadâ€™s `updatedAt` and `lastMessage` fields. The thread title is **always** the very first message in the thread and is never overwritten.

## Manual Storage Access

You can manually trigger storage operations from anywhere in your app:

```typescript
import { useCedarStore } from 'cedar-os';

function MyComponent() {
	const store = useCedarStore();

	const manualStorageOperations = async () => {
		// Manually load messages for current thread
		await store.getState().loadMessages();

		// Manually load threads for current user
		await store.getState().loadThreads();

		// Manually persist a single message (autoCreateThread optional)
		const message = {
			role: 'user',
			type: 'text',
			content: 'Hello world',
		};
		await store.getState().persistMessage(message); // autoCreateThread defaults to true
		await store.getState().persistMessage(message, false); // skip creating a new thread
	};
}
```

# User and Thread Management

**Setting User ID:**

<CodeGroup>

```typescript Using Store
import { useCedarStore } from 'cedar-os';

function LoginHandler({ userId }: { userId: string }) {
	const store = useCedarStore();

	// Set user context - Cedar will load this user's threads
	store.getState().setUserId(userId);

	return <YourChatComponent />;
}
```

```typescript Initial Configuration
import { CedarCopilot } from 'cedar-os';

function App({ userId }: { userId: string }) {
	return (
		<CedarCopilot
			userId={userId} // Set user ID in initial configuration
			storage={{
				type: 'local', // or 'remote', 'none', 'custom'
			}}>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

**Setting Thread ID:**

```typescript
import { useCedarStore } from 'cedar-os';

function ConversationSwitcher() {
	const store = useCedarStore();

	const switchToThread = (threadId: string) => {
		// Cedar will save current thread and load the new one
		store.getState().setCurrentThreadId(threadId);
	};

	return (
		<div>
			<button onClick={() => switchToThread('project-discussion')}>
				Project Discussion
			</button>
			<button onClick={() => switchToThread('support-ticket')}>
				Support Ticket
			</button>
		</div>
	);
}
```

## Error Handling

Cedar's storage system is designed to fail gracefully:

- **Storage failures** are silently caught to prevent UI crashes
- **Failed loads** return empty arrays rather than throwing errors
- **Network timeouts** (for remote storage) don't break the interface
- **Malformed data** is handled with safe fallbacks

## Next Steps

- Learn about [custom message rendering](/getting-started/chat/custom-message-rendering) for rich content
- Explore [streaming responses](/getting-started/chat/streaming) for real-time interactions
- Set up [agent backend connections](/getting-started/agent-backend-connection/agent-backend-connection) for AI responses

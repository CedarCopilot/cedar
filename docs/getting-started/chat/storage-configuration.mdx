---
title: 'Storage Configuration'
description: 'Configure how Cedar persists chat messages and manages threads'
---

Cedar provides a flexible storage system for managing chat messages with automatic persistence and **automatic thread management**. By default, Cedar uses **local storage** - no configuration required.

# Quick Start

Cedar works out of the box with browser localStorage - no setup needed. Optionally, you can configure the storage key.

With no configured storage adapter, Cedar will:

- Use local storage with 'cedar' prefix
- Use 'default' as the user ID (no userId needed)
- Load any existing threads for the default user
- Select the first thread or creates a 'default' thread
- Persist messages as they're added

# Storage Options

Cedar supports four storage adapters:

1. **Local Storage** (default) - Browser localStorage
2. **Remote Storage** - HTTP API endpoints
3. **No Storage** - Disables persistence
4. **Custom Storage** - Your own implementation

Configure storage by passing the `storage` prop to CedarCopilot:

<CodeGroup>

```typescript Local Storage (Default)
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			// No storage prop needed - uses local storage by default.
			// Optionally pass in user ID
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Local Storage (Custom Key)
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'local',
				options: {
					key: 'my-app', // Optional: defaults to 'cedar'
				},
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Remote Storage
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'remote',
				options: {
					baseURL: 'https://api.myapp.com',
					headers: {
						// Optional
						Authorization: 'Bearer your-token',
						'X-Custom-Header': 'value',
					},
				},
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript No Storage
import { CedarCopilot } from 'cedar-os';

function App() {
	return (
		<CedarCopilot storage={{ type: 'none' }} userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

```typescript Custom Storage
import { CedarCopilot } from 'cedar-os';

const myCustomAdapter = {
	async listThreads(userId) {
		return await myDatabase.getThreads(userId);
	},
	async loadMessages(userId, threadId) {
		return await myDatabase.getMessages(userId, threadId);
	},
	async persistMessage(userId, threadId, message) {
		await myDatabase.appendMessage(userId, threadId, message);
	},
};

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'custom',
				adapter: myCustomAdapter,
			}}
			userId='user-123'>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

# Additional Configuration Requirements by Storage Type

### Local Storage & No Storage

**No additional configuration needed** - these options work out of the box.

### Remote Storage

You can implement any or all of the following routes. **If an endpoint is not implemented, Cedar will gracefully skip that functionality.**
For example:

- If you don't implement the save messages endpoints, Cedar assumes you handle persistence elsewhere
- If you don't implement the list threads endpoints, Cedar will work with just one thread

**Single-User or Backend-Handled User Context:**
If your backend handles user context through authentication headers, implement these routes:

| Method | Endpoint                       | Purpose             | Request Body         | Response       |
| ------ | ------------------------------ | ------------------- | -------------------- | -------------- |
| GET    | `/threads`                     | List threads        | -                    | `ThreadMeta[]` |
| GET    | `/threads/{threadId}`          | Get thread messages | -                    | `Message[]`    |
| POST   | `/threads/{threadId}/messages` | Add single message  | `{message: Message}` | -              |

**Multi-User with URL-Based User Context:**
If your app has multiple users and you want to pass the user ID in the URL, implement these routes:

| Method | Endpoint                                   | Purpose                      | Request Body         | Response       |
| ------ | ------------------------------------------ | ---------------------------- | -------------------- | -------------- |
| GET    | `/threads?userId={id}`                     | List user's threads          | -                    | `ThreadMeta[]` |
| GET    | `/threads/{threadId}?userId={id}`          | Get user's thread messages   | -                    | `Message[]`    |
| POST   | `/threads/{threadId}/messages?userId={id}` | Add message to user's thread | `{message: Message}` | -              |

### Custom Storage

Implement your own storage solution by providing a custom adapter:

<CodeGroup>

```typescript Interface
interface BaseStorageAdapter {
	// Required methods
	listThreads(userId?: string | null): Promise<ThreadMeta[]>;
	loadMessages(
		userId: string | null | undefined,
		threadId: string
	): Promise<Message[]>;
	persistMessage(
		userId: string | null | undefined,
		threadId: string,
		message: Message
	): Promise<void>;
}
```

```typescript Example Implementation
import { useCedarStore } from 'cedar-os';

// Your custom storage implementation
const myCustomAdapter = {
	async listThreads(userId) {
		// Implement: return list of thread metadata
		return await myDatabase.getThreads(userId);
	},

	async loadMessages(userId, threadId) {
		// Implement: return messages for thread
		return await myDatabase.getMessages(userId, threadId);
	},

	async persistMessage(userId, threadId, message) {
		// Implement: save messages to your storage
		await myDatabase.saveMessages(userId, threadId, messages);
	},
};

function App() {
	const store = useCedarStore();

	store.getState().setStorageAdapter({
		type: 'custom',
		adapter: myCustomAdapter,
	});

	return <YourChatComponent />;
}
```

```typescript With CedarCopilot Configuration
import { CedarCopilot } from 'cedar-os';

// Your custom storage implementation
const myCustomAdapter = {
	async listThreads(userId) {
		return await myDatabase.getThreads(userId);
	},

	async loadMessages(userId, threadId) {
		return await myDatabase.getMessages(userId, threadId);
	},

	async persistMessage(userId, threadId, message) {
		await myDatabase.appendMessage(userId, threadId, message);
	},
};

function App() {
	return (
		<CedarCopilot
			storage={{
				type: 'custom',
				adapter: myCustomAdapter,
			}}
			userId='user-123' // User ID passed in initial configuration
		>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

## How Message Storage Works

Cedar automatically handles message storage operations in the following way:

**Thread & Message Loading:**

- **When user ID changes**: Automatically loads all threads for that user
- **When storage adapter changes**: Loads threads from the new storage system
- **When the thread ID changes**: Automatically loads in all messages for that thread

**Message Persistence:**

- **User messages**: Persisted immediately when sent via `sendMessage()`
- **Assistant responses**:
  - **Non-streaming**: Persisted immediately after LLM response completes
  - **Streaming**: Collected during streaming, persisted once when stream finishes

## Manual Storage Access

You can manually trigger storage operations from anywhere in your app:

```typescript
import { useCedarStore } from 'cedar-os';

function MyComponent() {
	const store = useCedarStore();

	const manualStorageOperations = async () => {
		// Manually load messages for current thread
		await store.getState().loadMessages();

		// Manually load threads for current user
		await store.getState().loadThreads();

		// Manually persist a single message
		const message = {
			role: 'user',
			type: 'text',
			content: 'Hello world',
		};
		await store.getState().persistMessage(message);
	};
}
```

## Thread Management

### ThreadMeta Type

Threads use the `ThreadMeta` interface for metadata:

```typescript
interface ThreadMeta {
	id: string; // Unique thread identifier
	title: string; // Display name for the thread
	updatedAt: string; // ISO timestamp of last update
	lastMessage: string; // Preview of the most recent message
}
```

# User and Thread Management

### User ID Behavior

Cedar supports multi-user scenarios with automatic thread loading:

| Scenario          | Behavior         | Storage Key/Endpoint     | Thread Management                |
| ----------------- | ---------------- | ------------------------ | -------------------------------- |
| No user ID prop   | Uses `'default'` | `cedar-threads-default`  | Auto-loads threads for 'default' |
| User ID provided  | Uses provided ID | `cedar-threads-{userId}` | Auto-loads threads for user      |
| User ID is `null` | Uses `'default'` | `cedar-threads-default`  | Auto-loads threads for 'default' |

**When a user ID changes, Cedar automatically:**

1. Loads all threads for that user
2. Selects the first thread
3. Creates a new thread if none exist
4. Loads messages for the selected thread

**Setting User ID:**

<CodeGroup>

```typescript Using Store
import { useCedarStore } from 'cedar-os';

function LoginHandler({ userId }: { userId: string }) {
	const store = useCedarStore();

	// Set user context - Cedar will load this user's threads
	store.getState().setUserId(userId);

	return <YourChatComponent />;
}
```

```typescript Initial Configuration
import { CedarCopilot } from 'cedar-os';

function App({ userId }: { userId: string }) {
	return (
		<CedarCopilot
			userId={userId} // Set user ID in initial configuration
			storage={{
				type: 'local', // or 'remote', 'none', 'custom'
			}}>
			<YourChatComponent />
		</CedarCopilot>
	);
}
```

</CodeGroup>

### Thread ID Behavior

Organize conversations into separate threads:

| Scenario            | Behavior         | Storage Key/Endpoint               |
| ------------------- | ---------------- | ---------------------------------- |
| No thread ID set    | Uses `'default'` | `cedar-thread-{userId}-default`    |
| Thread ID provided  | Uses provided ID | `cedar-thread-{userId}-{threadId}` |
| Thread ID is `null` | Uses `'default'` | `cedar-thread-{userId}-default`    |

**Setting Thread ID:**

```typescript
import { useCedarStore } from 'cedar-os';

function ConversationSwitcher() {
	const store = useCedarStore();

	const switchToThread = (threadId: string) => {
		// Cedar will save current thread and load the new one
		store.getState().setCurrentThreadId(threadId);
	};

	return (
		<div>
			<button onClick={() => switchToThread('project-discussion')}>
				Project Discussion
			</button>
			<button onClick={() => switchToThread('support-ticket')}>
				Support Ticket
			</button>
		</div>
	);
}
```

## Error Handling

Cedar's storage system is designed to fail gracefully:

- **Storage failures** are silently caught to prevent UI crashes
- **Failed loads** return empty arrays rather than throwing errors
- **Network timeouts** (for remote storage) don't break the interface
- **Malformed data** is handled with safe fallbacks

## Next Steps

- Learn about [custom message rendering](/getting-started/chat/custom-message-rendering) for rich content
- Explore [streaming responses](/getting-started/chat/streaming) for real-time interactions
- Set up [agent backend connections](/getting-started/agent-backend-connection/agent-backend-connection) for AI responses
